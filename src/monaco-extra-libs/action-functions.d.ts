/**
 * Adds a suffix to the end of each line
 * @param {string} suffix The string to append to each line
 * @returns void
 */
declare function append(suffix: string): void;

/**
 * Filters out lines from the output of the previous action if the given callback returns true for a line
 * @param {CallbackFilterLine} callback The provided callback will be called for every line that comes from the previous action
 * @returns void
 */
declare function filterLine(callback: typeof CallbackFilterLine): void;

/**
 * Callback that will be called with the content of every line and its corresponding number in the text.
 * If the callback returns true the line will not be given to the next action in the pipeline.
 * @param {string} lineContent The content of the line as a String
 * @param {number} lineNumber The number of the line in the text output of the previous action
 * @returns boolean
 */
declare function CallbackFilterLine(
    lineContent: string,
    lineNumber: number
): boolean;

/**
 * Filters lines matching a pattern (similar to Unix grep command)
 * @param {string | RegExp} pattern The string or regex pattern to search for
 * @param {boolean} [invert=false] If true, returns lines that do NOT match the pattern
 * @returns void
 */
declare function grep(pattern: string | RegExp, invert?: boolean): void;

/**
 * Parses the output of the previous action to a json object and gives it to the provided callback
 * @param {CallbackJsonParse} callback The provided callback will be called with the json object parsed from the output of the previous action
 * @param {number} [indentation=2] The indentation that is used to stringify the json object
 * @returns void
 */
declare function jsonParse(
    callback: typeof CallbackJsonParse,
    indentation?: number
): void;

/**
 * Callback that will be called with the parsed json from the output of the previous action.
 * The resulting object will be automatically given to an instance of the JsonStringify action
 * @param {Record<string, unknown>} json A json object parsed from the output of the previous action
 * @returns Record<string, unknown>
 */
declare function CallbackJsonParse(
    json: Record<string, unknown>
): Record<string, unknown>;

/**
 * Parses the output from the previous action as a json object and stringifies it
 * @param {number} [indentation=2] The indentation that is used to stringify the json object
 * @returns void
 */
declare function jsonStringify(indentation?: number): void;

/**
 * Reduces all lines into a new string
 * @param {CallbackReduce} callback The provided callback will be called for every line that comes from the previous action
 * @param {any} [initialValue=""] Initial value that will be given as the result value for the first call of the callback
 * @returns void
 */
declare function reduce(
    callback: typeof CallbackReduce,
    initialValue?: any
): void;

/**
 * Callback that will be called with the content of every
 * @param {any} result The result of the previous reduce step
 * @param {string} currentLine The content of the line as a String
 * @param {number} currentLineNumber The number of the line in the text output of the previous action
 * @param {string[]} inputLinesArray The original array of lines output by the previous action
 * @returns any
 */
declare function CallbackReduce(
    result: any,
    currentLine: string,
    currentLineNumber: number,
    inputLinesArray: string[]
): any;

/**
 * Reverses the order of all lines
 * @returns void
 */
declare function reverse(): void;

/**
 * Replaces the output of the previous action with a new string that is generated by the callback
 * @param {CallbackSetValue} callback The provided callback will be with the whole text that the previous action returned
 * @returns void
 */
declare function setValue(callback: typeof CallbackSetValue): void;

/**
 * Callback that will be called with the text that the previous action returned. The output that the next action receives
 * will be the result of this function as a single string
 * @param {string} input The whole text that was returned by the previous action
 * @returns string
 */
declare function CallbackSetValue(input: string): string;

/**
 * Sorts all lines using an optional comparator function
 * @param {CallbackSort} [callback] Optional comparator function for custom sorting. If not provided, lines are sorted alphabetically
 * @returns void
 */
declare function sort(callback?: typeof CallbackSort): void;

/**
 * Comparator function for sorting lines
 * @param {string} a The first line to compare
 * @param {string} b The second line to compare
 * @returns number A negative value if a should come before b, positive if a should come after b, or zero if they are equal
 */
declare function CallbackSort(a: string, b: string): number;

/**
 * Splits each line into multiple lines using a separator
 * @param {string | RegExp} separator The separator to split on (string or regex)
 * @returns void
 */
declare function split(separator: string | RegExp): void;

/**
 * Transforms all lines by replacing each line with the result of the callback
 * @param {CallbackTransformLine} callback The provided callback will be called for every line that comes from the previous action
 * @returns void
 */
declare function transformLine(callback: typeof CallbackTransformLine): void;

/**
 * Callback that will be called with the content of every line and its corresponding number in the text.
 * The lineContent of the original line will be replaced by the output of this function
 * @param {string} lineContent The content of the line as a String
 * @param {number} lineNumber The number of the line in the text output of the previous action
 * @returns string
 */
declare function CallbackTransformLine(
    lineContent: string,
    lineNumber: number
): string;

/**
 * Removes whitespace from the beginning and/or end of each line
 * @param {'both' | 'start' | 'end'} [mode='both'] Which whitespace to trim
 * @returns void
 */
declare function trim(mode?: 'both' | 'start' | 'end'): void;

/**
 * Removes whitespace from the beginning of each line
 * @returns void
 */
declare function trimStart(): void;

/**
 * Removes whitespace from the end of each line
 * @returns void
 */
declare function trimEnd(): void;

/**
 * Filters all lines and leaves only unique ones as a result for the next stage
 * @returns void
 */
declare function unique(): void;

declare interface TextwandlerFunctions {
    append: typeof append;
    filterLine: typeof filterLine;
    grep: typeof grep;
    jsonParse: typeof jsonParse;
    jsonStringify: typeof jsonStringify;
    reduce: typeof reduce;
    reverse: typeof reverse;
    setValue: typeof setValue;
    sort: typeof sort;
    split: typeof split;
    transformLine: typeof transformLine;
    trim: typeof trim;
    trimStart: typeof trimStart;
    trimEnd: typeof trimEnd;
    unique: typeof unique;
}

/**
 * Textwandler wrapper
 */
declare const textwandler: TextwandlerFunctions;

/**
 * Textwandler wrapper
 */
declare const tw: TextwandlerFunctions;
