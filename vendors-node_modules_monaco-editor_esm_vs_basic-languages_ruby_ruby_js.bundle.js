"use strict";
(self["webpackChunktext_wandler"] = self["webpackChunktext_wandler"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_ruby_ruby_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js":
/*!************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   conf: () => (/* binding */ conf),
/* harmony export */   language: () => (/* binding */ language)
/* harmony export */ });
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/


// src/basic-languages/ruby/ruby.ts
var conf = {
  comments: {
    lineComment: "#",
    blockComment: ["=begin", "=end"]
  },
  brackets: [
    ["(", ")"],
    ["{", "}"],
    ["[", "]"]
  ],
  autoClosingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"', close: '"' },
    { open: "'", close: "'" }
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"', close: '"' },
    { open: "'", close: "'" }
  ],
  indentationRules: {
    increaseIndentPattern: new RegExp(
      `^\\s*((begin|class|(private|protected)\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\sdo\\b)|([^#]*=\\s*(case|if|unless)))\\b([^#\\{;]|("|'|/).*\\4)*(#.*)?$`
    ),
    decreaseIndentPattern: new RegExp(
      "^\\s*([}\\]]([,)]?\\s*(#|$)|\\.[a-zA-Z_]\\w*\\b)|(end|rescue|ensure|else|elsif|when)\\b)"
    )
  }
};
var language = {
  tokenPostfix: ".ruby",
  keywords: [
    "__LINE__",
    "__ENCODING__",
    "__FILE__",
    "BEGIN",
    "END",
    "alias",
    "and",
    "begin",
    "break",
    "case",
    "class",
    "def",
    "defined?",
    "do",
    "else",
    "elsif",
    "end",
    "ensure",
    "for",
    "false",
    "if",
    "in",
    "module",
    "next",
    "nil",
    "not",
    "or",
    "redo",
    "rescue",
    "retry",
    "return",
    "self",
    "super",
    "then",
    "true",
    "undef",
    "unless",
    "until",
    "when",
    "while",
    "yield"
  ],
  keywordops: ["::", "..", "...", "?", ":", "=>"],
  builtins: [
    "require",
    "public",
    "private",
    "include",
    "extend",
    "attr_reader",
    "protected",
    "private_class_method",
    "protected_class_method",
    "new"
  ],
  // these are closed by 'end' (if, while and until are handled separately)
  declarations: [
    "module",
    "class",
    "def",
    "case",
    "do",
    "begin",
    "for",
    "if",
    "while",
    "until",
    "unless"
  ],
  linedecls: ["def", "case", "do", "begin", "for", "if", "while", "until", "unless"],
  operators: [
    "^",
    "&",
    "|",
    "<=>",
    "==",
    "===",
    "!~",
    "=~",
    ">",
    ">=",
    "<",
    "<=",
    "<<",
    ">>",
    "+",
    "-",
    "*",
    "/",
    "%",
    "**",
    "~",
    "+@",
    "-@",
    "[]",
    "[]=",
    "`",
    "+=",
    "-=",
    "*=",
    "**=",
    "/=",
    "^=",
    "%=",
    "<<=",
    ">>=",
    "&=",
    "&&=",
    "||=",
    "|="
  ],
  brackets: [
    { open: "(", close: ")", token: "delimiter.parenthesis" },
    { open: "{", close: "}", token: "delimiter.curly" },
    { open: "[", close: "]", token: "delimiter.square" }
  ],
  // we include these common regular expressions
  symbols: /[=><!~?:&|+\-*\/\^%\.]+/,
  // escape sequences
  escape: /(?:[abefnrstv\\"'\n\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,
  escapes: /\\(?:C\-(@escape|.)|c(@escape|.)|@escape)/,
  decpart: /\d(_?\d)*/,
  decimal: /0|@decpart/,
  delim: /[^a-zA-Z0-9\s\n\r]/,
  heredelim: /(?:\w+|'[^']*'|"[^"]*"|`[^`]*`)/,
  regexpctl: /[(){}\[\]\$\^|\-*+?\.]/,
  regexpesc: /\\(?:[AzZbBdDfnrstvwWn0\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,
  // The main tokenizer for our languages
  tokenizer: {
    // Main entry.
    // root.<decl> where decl is the current opening declaration (like 'class')
    root: [
      // identifiers and keywords
      // most complexity here is due to matching 'end' correctly with declarations.
      // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)
      [
        /^(\s*)([a-z_]\w*[!?=]?)/,
        [
          "white",
          {
            cases: {
              "for|until|while": {
                token: "keyword.$2",
                next: "@dodecl.$2"
              },
              "@declarations": {
                token: "keyword.$2",
                next: "@root.$2"
              },
              end: { token: "keyword.$S2", next: "@pop" },
              "@keywords": "keyword",
              "@builtins": "predefined",
              "@default": "identifier"
            }
          }
        ]
      ],
      [
        /[a-z_]\w*[!?=]?/,
        {
          cases: {
            "if|unless|while|until": {
              token: "keyword.$0x",
              next: "@modifier.$0x"
            },
            for: { token: "keyword.$2", next: "@dodecl.$2" },
            "@linedecls": { token: "keyword.$0", next: "@root.$0" },
            end: { token: "keyword.$S2", next: "@pop" },
            "@keywords": "keyword",
            "@builtins": "predefined",
            "@default": "identifier"
          }
        }
      ],
      [/[A-Z][\w]*[!?=]?/, "constructor.identifier"],
      // constant
      [/\$[\w]*/, "global.constant"],
      // global
      [/@[\w]*/, "namespace.instance.identifier"],
      // instance
      [/@@@[\w]*/, "namespace.class.identifier"],
      // class
      // here document
      [/<<[-~](@heredelim).*/, { token: "string.heredoc.delimiter", next: "@heredoc.$1" }],
      [/[ \t\r\n]+<<(@heredelim).*/, { token: "string.heredoc.delimiter", next: "@heredoc.$1" }],
      [/^<<(@heredelim).*/, { token: "string.heredoc.delimiter", next: "@heredoc.$1" }],
      // whitespace
      { include: "@whitespace" },
      // strings
      [/"/, { token: "string.d.delim", next: '@dstring.d."' }],
      [/'/, { token: "string.sq.delim", next: "@sstring.sq" }],
      // % literals. For efficiency, rematch in the 'pstring' state
      [/%([rsqxwW]|Q?)/, { token: "@rematch", next: "pstring" }],
      // commands and symbols
      [/`/, { token: "string.x.delim", next: "@dstring.x.`" }],
      [/:(\w|[$@])\w*[!?=]?/, "string.s"],
      [/:"/, { token: "string.s.delim", next: '@dstring.s."' }],
      [/:'/, { token: "string.s.delim", next: "@sstring.s" }],
      // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line
      [/\/(?=(\\\/|[^\/\n])+\/)/, { token: "regexp.delim", next: "@regexp" }],
      // delimiters and operators
      [/[{}()\[\]]/, "@brackets"],
      [
        /@symbols/,
        {
          cases: {
            "@keywordops": "keyword",
            "@operators": "operator",
            "@default": ""
          }
        }
      ],
      [/[;,]/, "delimiter"],
      // numbers
      [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, "number.hex"],
      [/0[_oO][0-7](_?[0-7])*/, "number.octal"],
      [/0[bB][01](_?[01])*/, "number.binary"],
      [/0[dD]@decpart/, "number"],
      [
        /@decimal((\.@decpart)?([eE][\-+]?@decpart)?)/,
        {
          cases: {
            $1: "number.float",
            "@default": "number"
          }
        }
      ]
    ],
    // used to not treat a 'do' as a block opener if it occurs on the same
    // line as a 'do' statement: 'while|until|for'
    // dodecl.<decl> where decl is the declarations started, like 'while'
    dodecl: [
      [/^/, { token: "", switchTo: "@root.$S2" }],
      // get out of do-skipping mode on a new line
      [
        /[a-z_]\w*[!?=]?/,
        {
          cases: {
            end: { token: "keyword.$S2", next: "@pop" },
            // end on same line
            do: { token: "keyword", switchTo: "@root.$S2" },
            // do on same line: not an open bracket here
            "@linedecls": {
              token: "@rematch",
              switchTo: "@root.$S2"
            },
            // other declaration on same line: rematch
            "@keywords": "keyword",
            "@builtins": "predefined",
            "@default": "identifier"
          }
        }
      ],
      { include: "@root" }
    ],
    // used to prevent potential modifiers ('if|until|while|unless') to match
    // with 'end' keywords.
    // modifier.<decl>x where decl is the declaration starter, like 'if'
    modifier: [
      [/^/, "", "@pop"],
      // it was a modifier: get out of modifier mode on a new line
      [
        /[a-z_]\w*[!?=]?/,
        {
          cases: {
            end: { token: "keyword.$S2", next: "@pop" },
            // end on same line
            "then|else|elsif|do": {
              token: "keyword",
              switchTo: "@root.$S2"
            },
            // real declaration and not a modifier
            "@linedecls": {
              token: "@rematch",
              switchTo: "@root.$S2"
            },
            // other declaration => not a modifier
            "@keywords": "keyword",
            "@builtins": "predefined",
            "@default": "identifier"
          }
        }
      ],
      { include: "@root" }
    ],
    // single quote strings (also used for symbols)
    // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)
    sstring: [
      [/[^\\']+/, "string.$S2"],
      [/\\\\|\\'|\\$/, "string.$S2.escape"],
      [/\\./, "string.$S2.invalid"],
      [/'/, { token: "string.$S2.delim", next: "@pop" }]
    ],
    // double quoted "string".
    // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)
    // and delim is the ending delimiter (" or `)
    dstring: [
      [/[^\\`"#]+/, "string.$S2"],
      [/#/, "string.$S2.escape", "@interpolated"],
      [/\\$/, "string.$S2.escape"],
      [/@escapes/, "string.$S2.escape"],
      [/\\./, "string.$S2.escape.invalid"],
      [
        /[`"]/,
        {
          cases: {
            "$#==$S3": { token: "string.$S2.delim", next: "@pop" },
            "@default": "string.$S2"
          }
        }
      ]
    ],
    // literal documents
    // heredoc.<close> where close is the closing delimiter
    heredoc: [
      [
        /^(\s*)(@heredelim)$/,
        {
          cases: {
            "$2==$S2": ["string.heredoc", { token: "string.heredoc.delimiter", next: "@pop" }],
            "@default": ["string.heredoc", "string.heredoc"]
          }
        }
      ],
      [/.*/, "string.heredoc"]
    ],
    // interpolated sequence
    interpolated: [
      [/\$\w*/, "global.constant", "@pop"],
      [/@\w*/, "namespace.class.identifier", "@pop"],
      [/@@@\w*/, "namespace.instance.identifier", "@pop"],
      [
        /[{]/,
        {
          token: "string.escape.curly",
          switchTo: "@interpolated_compound"
        }
      ],
      ["", "", "@pop"]
      // just a # is interpreted as a #
    ],
    // any code
    interpolated_compound: [
      [/[}]/, { token: "string.escape.curly", next: "@pop" }],
      { include: "@root" }
    ],
    // %r quoted regexp
    // pregexp.<open>.<close> where open/close are the open/close delimiter
    pregexp: [
      { include: "@whitespace" },
      // turns out that you can quote using regex control characters, aargh!
      // for example; %r|kgjgaj| is ok (even though | is used for alternation)
      // so, we need to match those first
      [
        /[^\(\{\[\\]/,
        {
          cases: {
            "$#==$S3": { token: "regexp.delim", next: "@pop" },
            "$#==$S2": { token: "regexp.delim", next: "@push" },
            // nested delimiters are allowed..
            "~[)}\\]]": "@brackets.regexp.escape.control",
            "~@regexpctl": "regexp.escape.control",
            "@default": "regexp"
          }
        }
      ],
      { include: "@regexcontrol" }
    ],
    // We match regular expression quite precisely
    regexp: [
      { include: "@regexcontrol" },
      [/[^\\\/]/, "regexp"],
      ["/[ixmp]*", { token: "regexp.delim" }, "@pop"]
    ],
    regexcontrol: [
      [
        /(\{)(\d+(?:,\d*)?)(\})/,
        [
          "@brackets.regexp.escape.control",
          "regexp.escape.control",
          "@brackets.regexp.escape.control"
        ]
      ],
      [
        /(\[)(\^?)/,
        ["@brackets.regexp.escape.control", { token: "regexp.escape.control", next: "@regexrange" }]
      ],
      [/(\()(\?[:=!])/, ["@brackets.regexp.escape.control", "regexp.escape.control"]],
      [/\(\?#/, { token: "regexp.escape.control", next: "@regexpcomment" }],
      [/[()]/, "@brackets.regexp.escape.control"],
      [/@regexpctl/, "regexp.escape.control"],
      [/\\$/, "regexp.escape"],
      [/@regexpesc/, "regexp.escape"],
      [/\\\./, "regexp.invalid"],
      [/#/, "regexp.escape", "@interpolated"]
    ],
    regexrange: [
      [/-/, "regexp.escape.control"],
      [/\^/, "regexp.invalid"],
      [/\\$/, "regexp.escape"],
      [/@regexpesc/, "regexp.escape"],
      [/[^\]]/, "regexp"],
      [/\]/, "@brackets.regexp.escape.control", "@pop"]
    ],
    regexpcomment: [
      [/[^)]+/, "comment"],
      [/\)/, { token: "regexp.escape.control", next: "@pop" }]
    ],
    // % quoted strings
    // A bit repetitive since we need to often special case the kind of ending delimiter
    pstring: [
      [/%([qws])\(/, { token: "string.$1.delim", switchTo: "@qstring.$1.(.)" }],
      [/%([qws])\[/, { token: "string.$1.delim", switchTo: "@qstring.$1.[.]" }],
      [/%([qws])\{/, { token: "string.$1.delim", switchTo: "@qstring.$1.{.}" }],
      [/%([qws])</, { token: "string.$1.delim", switchTo: "@qstring.$1.<.>" }],
      [/%([qws])(@delim)/, { token: "string.$1.delim", switchTo: "@qstring.$1.$2.$2" }],
      [/%r\(/, { token: "regexp.delim", switchTo: "@pregexp.(.)" }],
      [/%r\[/, { token: "regexp.delim", switchTo: "@pregexp.[.]" }],
      [/%r\{/, { token: "regexp.delim", switchTo: "@pregexp.{.}" }],
      [/%r</, { token: "regexp.delim", switchTo: "@pregexp.<.>" }],
      [/%r(@delim)/, { token: "regexp.delim", switchTo: "@pregexp.$1.$1" }],
      [/%(x|W|Q?)\(/, { token: "string.$1.delim", switchTo: "@qqstring.$1.(.)" }],
      [/%(x|W|Q?)\[/, { token: "string.$1.delim", switchTo: "@qqstring.$1.[.]" }],
      [/%(x|W|Q?)\{/, { token: "string.$1.delim", switchTo: "@qqstring.$1.{.}" }],
      [/%(x|W|Q?)</, { token: "string.$1.delim", switchTo: "@qqstring.$1.<.>" }],
      [/%(x|W|Q?)(@delim)/, { token: "string.$1.delim", switchTo: "@qqstring.$1.$2.$2" }],
      [/%([rqwsxW]|Q?)./, { token: "invalid", next: "@pop" }],
      // recover
      [/./, { token: "invalid", next: "@pop" }]
      // recover
    ],
    // non-expanded quoted string.
    // qstring.<kind>.<open>.<close>
    //  kind = q|w|s  (single quote, array, symbol)
    //  open = open delimiter
    //  close = close delimiter
    qstring: [
      [/\\$/, "string.$S2.escape"],
      [/\\./, "string.$S2.escape"],
      [
        /./,
        {
          cases: {
            "$#==$S4": { token: "string.$S2.delim", next: "@pop" },
            "$#==$S3": { token: "string.$S2.delim", next: "@push" },
            // nested delimiters are allowed..
            "@default": "string.$S2"
          }
        }
      ]
    ],
    // expanded quoted string.
    // qqstring.<kind>.<open>.<close>
    //  kind = Q|W|x  (double quote, array, command)
    //  open = open delimiter
    //  close = close delimiter
    qqstring: [[/#/, "string.$S2.escape", "@interpolated"], { include: "@qstring" }],
    // whitespace & comments
    whitespace: [
      [/[ \t\r\n]+/, ""],
      [/^\s*=begin\b/, "comment", "@comment"],
      [/#.*$/, "comment"]
    ],
    comment: [
      [/[^=]+/, "comment"],
      [/^\s*=begin\b/, "comment.invalid"],
      // nested comment
      [/^\s*=end\b.*/, "comment", "@pop"],
      [/[=]/, "comment"]
    ]
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzaWMtbGFuZ3VhZ2VzX3J1YnlfcnVieV9qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE9BQU8sS0FBSztBQUNaO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSxZQUFZLEdBQUc7QUFDN0IsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNLFFBQVEsWUFBWSxHQUFHO0FBQzdCLE1BQU0sdUJBQXVCO0FBQzdCLE1BQU0sdUJBQXVCO0FBQzdCLE1BQU0sdUJBQXVCO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzTEFBc0w7QUFDdEw7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5Q0FBeUM7QUFDbEUseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFCQUFxQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL3RleHQtd2FuZGxlci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNpYy1sYW5ndWFnZXMvcnVieS9ydWJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFZlcnNpb246IDAuNDguMCgwMDM3YjEzZmI1ZDE4NmZkZjFlN2RmNTFhOTQxNmEyZGUyYjhjNjcwKVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L21vbmFjby1lZGl0b3IvYmxvYi9tYWluL0xJQ0VOU0UudHh0XG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4vLyBzcmMvYmFzaWMtbGFuZ3VhZ2VzL3J1YnkvcnVieS50c1xudmFyIGNvbmYgPSB7XG4gIGNvbW1lbnRzOiB7XG4gICAgbGluZUNvbW1lbnQ6IFwiI1wiLFxuICAgIGJsb2NrQ29tbWVudDogW1wiPWJlZ2luXCIsIFwiPWVuZFwiXVxuICB9LFxuICBicmFja2V0czogW1xuICAgIFtcIihcIiwgXCIpXCJdLFxuICAgIFtcIntcIiwgXCJ9XCJdLFxuICAgIFtcIltcIiwgXCJdXCJdXG4gIF0sXG4gIGF1dG9DbG9zaW5nUGFpcnM6IFtcbiAgICB7IG9wZW46IFwie1wiLCBjbG9zZTogXCJ9XCIgfSxcbiAgICB7IG9wZW46IFwiW1wiLCBjbG9zZTogXCJdXCIgfSxcbiAgICB7IG9wZW46IFwiKFwiLCBjbG9zZTogXCIpXCIgfSxcbiAgICB7IG9wZW46ICdcIicsIGNsb3NlOiAnXCInIH0sXG4gICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiIH1cbiAgXSxcbiAgc3Vycm91bmRpbmdQYWlyczogW1xuICAgIHsgb3BlbjogXCJ7XCIsIGNsb3NlOiBcIn1cIiB9LFxuICAgIHsgb3BlbjogXCJbXCIsIGNsb3NlOiBcIl1cIiB9LFxuICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiB9LFxuICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicgfSxcbiAgICB7IG9wZW46IFwiJ1wiLCBjbG9zZTogXCInXCIgfVxuICBdLFxuICBpbmRlbnRhdGlvblJ1bGVzOiB7XG4gICAgaW5jcmVhc2VJbmRlbnRQYXR0ZXJuOiBuZXcgUmVnRXhwKFxuICAgICAgYF5cXFxccyooKGJlZ2lufGNsYXNzfChwcml2YXRlfHByb3RlY3RlZClcXFxccytkZWZ8ZGVmfGVsc2V8ZWxzaWZ8ZW5zdXJlfGZvcnxpZnxtb2R1bGV8cmVzY3VlfHVubGVzc3x1bnRpbHx3aGVufHdoaWxlfGNhc2UpfChbXiNdKlxcXFxzZG9cXFxcYil8KFteI10qPVxcXFxzKihjYXNlfGlmfHVubGVzcykpKVxcXFxiKFteI1xcXFx7O118KFwifCd8LykuKlxcXFw0KSooIy4qKT8kYFxuICAgICksXG4gICAgZGVjcmVhc2VJbmRlbnRQYXR0ZXJuOiBuZXcgUmVnRXhwKFxuICAgICAgXCJeXFxcXHMqKFt9XFxcXF1dKFssKV0/XFxcXHMqKCN8JCl8XFxcXC5bYS16QS1aX11cXFxcdypcXFxcYil8KGVuZHxyZXNjdWV8ZW5zdXJlfGVsc2V8ZWxzaWZ8d2hlbilcXFxcYilcIlxuICAgIClcbiAgfVxufTtcbnZhciBsYW5ndWFnZSA9IHtcbiAgdG9rZW5Qb3N0Zml4OiBcIi5ydWJ5XCIsXG4gIGtleXdvcmRzOiBbXG4gICAgXCJfX0xJTkVfX1wiLFxuICAgIFwiX19FTkNPRElOR19fXCIsXG4gICAgXCJfX0ZJTEVfX1wiLFxuICAgIFwiQkVHSU5cIixcbiAgICBcIkVORFwiLFxuICAgIFwiYWxpYXNcIixcbiAgICBcImFuZFwiLFxuICAgIFwiYmVnaW5cIixcbiAgICBcImJyZWFrXCIsXG4gICAgXCJjYXNlXCIsXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiZGVmXCIsXG4gICAgXCJkZWZpbmVkP1wiLFxuICAgIFwiZG9cIixcbiAgICBcImVsc2VcIixcbiAgICBcImVsc2lmXCIsXG4gICAgXCJlbmRcIixcbiAgICBcImVuc3VyZVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmYWxzZVwiLFxuICAgIFwiaWZcIixcbiAgICBcImluXCIsXG4gICAgXCJtb2R1bGVcIixcbiAgICBcIm5leHRcIixcbiAgICBcIm5pbFwiLFxuICAgIFwibm90XCIsXG4gICAgXCJvclwiLFxuICAgIFwicmVkb1wiLFxuICAgIFwicmVzY3VlXCIsXG4gICAgXCJyZXRyeVwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJzZWxmXCIsXG4gICAgXCJzdXBlclwiLFxuICAgIFwidGhlblwiLFxuICAgIFwidHJ1ZVwiLFxuICAgIFwidW5kZWZcIixcbiAgICBcInVubGVzc1wiLFxuICAgIFwidW50aWxcIixcbiAgICBcIndoZW5cIixcbiAgICBcIndoaWxlXCIsXG4gICAgXCJ5aWVsZFwiXG4gIF0sXG4gIGtleXdvcmRvcHM6IFtcIjo6XCIsIFwiLi5cIiwgXCIuLi5cIiwgXCI/XCIsIFwiOlwiLCBcIj0+XCJdLFxuICBidWlsdGluczogW1xuICAgIFwicmVxdWlyZVwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJwcml2YXRlXCIsXG4gICAgXCJpbmNsdWRlXCIsXG4gICAgXCJleHRlbmRcIixcbiAgICBcImF0dHJfcmVhZGVyXCIsXG4gICAgXCJwcm90ZWN0ZWRcIixcbiAgICBcInByaXZhdGVfY2xhc3NfbWV0aG9kXCIsXG4gICAgXCJwcm90ZWN0ZWRfY2xhc3NfbWV0aG9kXCIsXG4gICAgXCJuZXdcIlxuICBdLFxuICAvLyB0aGVzZSBhcmUgY2xvc2VkIGJ5ICdlbmQnIChpZiwgd2hpbGUgYW5kIHVudGlsIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkpXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIFwibW9kdWxlXCIsXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiZGVmXCIsXG4gICAgXCJjYXNlXCIsXG4gICAgXCJkb1wiLFxuICAgIFwiYmVnaW5cIixcbiAgICBcImZvclwiLFxuICAgIFwiaWZcIixcbiAgICBcIndoaWxlXCIsXG4gICAgXCJ1bnRpbFwiLFxuICAgIFwidW5sZXNzXCJcbiAgXSxcbiAgbGluZWRlY2xzOiBbXCJkZWZcIiwgXCJjYXNlXCIsIFwiZG9cIiwgXCJiZWdpblwiLCBcImZvclwiLCBcImlmXCIsIFwid2hpbGVcIiwgXCJ1bnRpbFwiLCBcInVubGVzc1wiXSxcbiAgb3BlcmF0b3JzOiBbXG4gICAgXCJeXCIsXG4gICAgXCImXCIsXG4gICAgXCJ8XCIsXG4gICAgXCI8PT5cIixcbiAgICBcIj09XCIsXG4gICAgXCI9PT1cIixcbiAgICBcIiF+XCIsXG4gICAgXCI9flwiLFxuICAgIFwiPlwiLFxuICAgIFwiPj1cIixcbiAgICBcIjxcIixcbiAgICBcIjw9XCIsXG4gICAgXCI8PFwiLFxuICAgIFwiPj5cIixcbiAgICBcIitcIixcbiAgICBcIi1cIixcbiAgICBcIipcIixcbiAgICBcIi9cIixcbiAgICBcIiVcIixcbiAgICBcIioqXCIsXG4gICAgXCJ+XCIsXG4gICAgXCIrQFwiLFxuICAgIFwiLUBcIixcbiAgICBcIltdXCIsXG4gICAgXCJbXT1cIixcbiAgICBcImBcIixcbiAgICBcIis9XCIsXG4gICAgXCItPVwiLFxuICAgIFwiKj1cIixcbiAgICBcIioqPVwiLFxuICAgIFwiLz1cIixcbiAgICBcIl49XCIsXG4gICAgXCIlPVwiLFxuICAgIFwiPDw9XCIsXG4gICAgXCI+Pj1cIixcbiAgICBcIiY9XCIsXG4gICAgXCImJj1cIixcbiAgICBcInx8PVwiLFxuICAgIFwifD1cIlxuICBdLFxuICBicmFja2V0czogW1xuICAgIHsgb3BlbjogXCIoXCIsIGNsb3NlOiBcIilcIiwgdG9rZW46IFwiZGVsaW1pdGVyLnBhcmVudGhlc2lzXCIgfSxcbiAgICB7IG9wZW46IFwie1wiLCBjbG9zZTogXCJ9XCIsIHRva2VuOiBcImRlbGltaXRlci5jdXJseVwiIH0sXG4gICAgeyBvcGVuOiBcIltcIiwgY2xvc2U6IFwiXVwiLCB0b2tlbjogXCJkZWxpbWl0ZXIuc3F1YXJlXCIgfVxuICBdLFxuICAvLyB3ZSBpbmNsdWRlIHRoZXNlIGNvbW1vbiByZWd1bGFyIGV4cHJlc3Npb25zXG4gIHN5bWJvbHM6IC9bPT48IX4/OiZ8K1xcLSpcXC9cXF4lXFwuXSsvLFxuICAvLyBlc2NhcGUgc2VxdWVuY2VzXG4gIGVzY2FwZTogLyg/OlthYmVmbnJzdHZcXFxcXCInXFxuXFxyXXxbMC03XXsxLDN9fHhbMC05QS1GYS1mXXsxLDJ9fHVbMC05QS1GYS1mXXs0fSkvLFxuICBlc2NhcGVzOiAvXFxcXCg/OkNcXC0oQGVzY2FwZXwuKXxjKEBlc2NhcGV8Lil8QGVzY2FwZSkvLFxuICBkZWNwYXJ0OiAvXFxkKF8/XFxkKSovLFxuICBkZWNpbWFsOiAvMHxAZGVjcGFydC8sXG4gIGRlbGltOiAvW15hLXpBLVowLTlcXHNcXG5cXHJdLyxcbiAgaGVyZWRlbGltOiAvKD86XFx3K3wnW14nXSonfFwiW15cIl0qXCJ8YFteYF0qYCkvLFxuICByZWdleHBjdGw6IC9bKCl7fVxcW1xcXVxcJFxcXnxcXC0qKz9cXC5dLyxcbiAgcmVnZXhwZXNjOiAvXFxcXCg/OltBelpiQmREZm5yc3R2d1duMFxcXFxcXC9dfEByZWdleHBjdGx8Y1tBLVpdfHhbMC05YS1mQS1GXXsyfXx1WzAtOWEtZkEtRl17NH0pPy8sXG4gIC8vIFRoZSBtYWluIHRva2VuaXplciBmb3Igb3VyIGxhbmd1YWdlc1xuICB0b2tlbml6ZXI6IHtcbiAgICAvLyBNYWluIGVudHJ5LlxuICAgIC8vIHJvb3QuPGRlY2w+IHdoZXJlIGRlY2wgaXMgdGhlIGN1cnJlbnQgb3BlbmluZyBkZWNsYXJhdGlvbiAobGlrZSAnY2xhc3MnKVxuICAgIHJvb3Q6IFtcbiAgICAgIC8vIGlkZW50aWZpZXJzIGFuZCBrZXl3b3Jkc1xuICAgICAgLy8gbW9zdCBjb21wbGV4aXR5IGhlcmUgaXMgZHVlIHRvIG1hdGNoaW5nICdlbmQnIGNvcnJlY3RseSB3aXRoIGRlY2xhcmF0aW9ucy5cbiAgICAgIC8vIFdlIGRpc3Rpbmd1aXNoIGEgZGVjbGFyYXRpb24gdGhhdCBjb21lcyBmaXJzdCBvbiBhIGxpbmUsIHZlcnN1cyBkZWNsYXJhdGlvbnMgZnVydGhlciBvbiBhIGxpbmUgKHdoaWNoIGFyZSBtb3N0IGxpa2V5IG1vZGlmaWVycylcbiAgICAgIFtcbiAgICAgICAgL14oXFxzKikoW2Etel9dXFx3KlshPz1dPykvLFxuICAgICAgICBbXG4gICAgICAgICAgXCJ3aGl0ZVwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgIFwiZm9yfHVudGlsfHdoaWxlXCI6IHtcbiAgICAgICAgICAgICAgICB0b2tlbjogXCJrZXl3b3JkLiQyXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJAZG9kZWNsLiQyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJAZGVjbGFyYXRpb25zXCI6IHtcbiAgICAgICAgICAgICAgICB0b2tlbjogXCJrZXl3b3JkLiQyXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJAcm9vdC4kMlwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVuZDogeyB0b2tlbjogXCJrZXl3b3JkLiRTMlwiLCBuZXh0OiBcIkBwb3BcIiB9LFxuICAgICAgICAgICAgICBcIkBrZXl3b3Jkc1wiOiBcImtleXdvcmRcIixcbiAgICAgICAgICAgICAgXCJAYnVpbHRpbnNcIjogXCJwcmVkZWZpbmVkXCIsXG4gICAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogXCJpZGVudGlmaWVyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIC9bYS16X11cXHcqWyE/PV0/LyxcbiAgICAgICAge1xuICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICBcImlmfHVubGVzc3x3aGlsZXx1bnRpbFwiOiB7XG4gICAgICAgICAgICAgIHRva2VuOiBcImtleXdvcmQuJDB4XCIsXG4gICAgICAgICAgICAgIG5leHQ6IFwiQG1vZGlmaWVyLiQweFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yOiB7IHRva2VuOiBcImtleXdvcmQuJDJcIiwgbmV4dDogXCJAZG9kZWNsLiQyXCIgfSxcbiAgICAgICAgICAgIFwiQGxpbmVkZWNsc1wiOiB7IHRva2VuOiBcImtleXdvcmQuJDBcIiwgbmV4dDogXCJAcm9vdC4kMFwiIH0sXG4gICAgICAgICAgICBlbmQ6IHsgdG9rZW46IFwia2V5d29yZC4kUzJcIiwgbmV4dDogXCJAcG9wXCIgfSxcbiAgICAgICAgICAgIFwiQGtleXdvcmRzXCI6IFwia2V5d29yZFwiLFxuICAgICAgICAgICAgXCJAYnVpbHRpbnNcIjogXCJwcmVkZWZpbmVkXCIsXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwiaWRlbnRpZmllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgWy9bQS1aXVtcXHddKlshPz1dPy8sIFwiY29uc3RydWN0b3IuaWRlbnRpZmllclwiXSxcbiAgICAgIC8vIGNvbnN0YW50XG4gICAgICBbL1xcJFtcXHddKi8sIFwiZ2xvYmFsLmNvbnN0YW50XCJdLFxuICAgICAgLy8gZ2xvYmFsXG4gICAgICBbL0BbXFx3XSovLCBcIm5hbWVzcGFjZS5pbnN0YW5jZS5pZGVudGlmaWVyXCJdLFxuICAgICAgLy8gaW5zdGFuY2VcbiAgICAgIFsvQEBAW1xcd10qLywgXCJuYW1lc3BhY2UuY2xhc3MuaWRlbnRpZmllclwiXSxcbiAgICAgIC8vIGNsYXNzXG4gICAgICAvLyBoZXJlIGRvY3VtZW50XG4gICAgICBbLzw8Wy1+XShAaGVyZWRlbGltKS4qLywgeyB0b2tlbjogXCJzdHJpbmcuaGVyZWRvYy5kZWxpbWl0ZXJcIiwgbmV4dDogXCJAaGVyZWRvYy4kMVwiIH1dLFxuICAgICAgWy9bIFxcdFxcclxcbl0rPDwoQGhlcmVkZWxpbSkuKi8sIHsgdG9rZW46IFwic3RyaW5nLmhlcmVkb2MuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQGhlcmVkb2MuJDFcIiB9XSxcbiAgICAgIFsvXjw8KEBoZXJlZGVsaW0pLiovLCB7IHRva2VuOiBcInN0cmluZy5oZXJlZG9jLmRlbGltaXRlclwiLCBuZXh0OiBcIkBoZXJlZG9jLiQxXCIgfV0sXG4gICAgICAvLyB3aGl0ZXNwYWNlXG4gICAgICB7IGluY2x1ZGU6IFwiQHdoaXRlc3BhY2VcIiB9LFxuICAgICAgLy8gc3RyaW5nc1xuICAgICAgWy9cIi8sIHsgdG9rZW46IFwic3RyaW5nLmQuZGVsaW1cIiwgbmV4dDogJ0Bkc3RyaW5nLmQuXCInIH1dLFxuICAgICAgWy8nLywgeyB0b2tlbjogXCJzdHJpbmcuc3EuZGVsaW1cIiwgbmV4dDogXCJAc3N0cmluZy5zcVwiIH1dLFxuICAgICAgLy8gJSBsaXRlcmFscy4gRm9yIGVmZmljaWVuY3ksIHJlbWF0Y2ggaW4gdGhlICdwc3RyaW5nJyBzdGF0ZVxuICAgICAgWy8lKFtyc3F4d1ddfFE/KS8sIHsgdG9rZW46IFwiQHJlbWF0Y2hcIiwgbmV4dDogXCJwc3RyaW5nXCIgfV0sXG4gICAgICAvLyBjb21tYW5kcyBhbmQgc3ltYm9sc1xuICAgICAgWy9gLywgeyB0b2tlbjogXCJzdHJpbmcueC5kZWxpbVwiLCBuZXh0OiBcIkBkc3RyaW5nLnguYFwiIH1dLFxuICAgICAgWy86KFxcd3xbJEBdKVxcdypbIT89XT8vLCBcInN0cmluZy5zXCJdLFxuICAgICAgWy86XCIvLCB7IHRva2VuOiBcInN0cmluZy5zLmRlbGltXCIsIG5leHQ6ICdAZHN0cmluZy5zLlwiJyB9XSxcbiAgICAgIFsvOicvLCB7IHRva2VuOiBcInN0cmluZy5zLmRlbGltXCIsIG5leHQ6IFwiQHNzdHJpbmcuc1wiIH1dLFxuICAgICAgLy8gcmVndWxhciBleHByZXNzaW9ucy4gTG9va2FoZWFkIGZvciBhIChub3QgZXNjYXBlZCkgY2xvc2luZyBmb3J3YXJkc2xhc2ggb24gdGhlIHNhbWUgbGluZVxuICAgICAgWy9cXC8oPz0oXFxcXFxcL3xbXlxcL1xcbl0pK1xcLykvLCB7IHRva2VuOiBcInJlZ2V4cC5kZWxpbVwiLCBuZXh0OiBcIkByZWdleHBcIiB9XSxcbiAgICAgIC8vIGRlbGltaXRlcnMgYW5kIG9wZXJhdG9yc1xuICAgICAgWy9be30oKVxcW1xcXV0vLCBcIkBicmFja2V0c1wiXSxcbiAgICAgIFtcbiAgICAgICAgL0BzeW1ib2xzLyxcbiAgICAgICAge1xuICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICBcIkBrZXl3b3Jkb3BzXCI6IFwia2V5d29yZFwiLFxuICAgICAgICAgICAgXCJAb3BlcmF0b3JzXCI6IFwib3BlcmF0b3JcIixcbiAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogXCJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFsvWzssXS8sIFwiZGVsaW1pdGVyXCJdLFxuICAgICAgLy8gbnVtYmVyc1xuICAgICAgWy8wW3hYXVswLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKi8sIFwibnVtYmVyLmhleFwiXSxcbiAgICAgIFsvMFtfb09dWzAtN10oXz9bMC03XSkqLywgXCJudW1iZXIub2N0YWxcIl0sXG4gICAgICBbLzBbYkJdWzAxXShfP1swMV0pKi8sIFwibnVtYmVyLmJpbmFyeVwiXSxcbiAgICAgIFsvMFtkRF1AZGVjcGFydC8sIFwibnVtYmVyXCJdLFxuICAgICAgW1xuICAgICAgICAvQGRlY2ltYWwoKFxcLkBkZWNwYXJ0KT8oW2VFXVtcXC0rXT9AZGVjcGFydCk/KS8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgJDE6IFwibnVtYmVyLmZsb2F0XCIsXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwibnVtYmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdLFxuICAgIC8vIHVzZWQgdG8gbm90IHRyZWF0IGEgJ2RvJyBhcyBhIGJsb2NrIG9wZW5lciBpZiBpdCBvY2N1cnMgb24gdGhlIHNhbWVcbiAgICAvLyBsaW5lIGFzIGEgJ2RvJyBzdGF0ZW1lbnQ6ICd3aGlsZXx1bnRpbHxmb3InXG4gICAgLy8gZG9kZWNsLjxkZWNsPiB3aGVyZSBkZWNsIGlzIHRoZSBkZWNsYXJhdGlvbnMgc3RhcnRlZCwgbGlrZSAnd2hpbGUnXG4gICAgZG9kZWNsOiBbXG4gICAgICBbL14vLCB7IHRva2VuOiBcIlwiLCBzd2l0Y2hUbzogXCJAcm9vdC4kUzJcIiB9XSxcbiAgICAgIC8vIGdldCBvdXQgb2YgZG8tc2tpcHBpbmcgbW9kZSBvbiBhIG5ldyBsaW5lXG4gICAgICBbXG4gICAgICAgIC9bYS16X11cXHcqWyE/PV0/LyxcbiAgICAgICAge1xuICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICBlbmQ6IHsgdG9rZW46IFwia2V5d29yZC4kUzJcIiwgbmV4dDogXCJAcG9wXCIgfSxcbiAgICAgICAgICAgIC8vIGVuZCBvbiBzYW1lIGxpbmVcbiAgICAgICAgICAgIGRvOiB7IHRva2VuOiBcImtleXdvcmRcIiwgc3dpdGNoVG86IFwiQHJvb3QuJFMyXCIgfSxcbiAgICAgICAgICAgIC8vIGRvIG9uIHNhbWUgbGluZTogbm90IGFuIG9wZW4gYnJhY2tldCBoZXJlXG4gICAgICAgICAgICBcIkBsaW5lZGVjbHNcIjoge1xuICAgICAgICAgICAgICB0b2tlbjogXCJAcmVtYXRjaFwiLFxuICAgICAgICAgICAgICBzd2l0Y2hUbzogXCJAcm9vdC4kUzJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIG90aGVyIGRlY2xhcmF0aW9uIG9uIHNhbWUgbGluZTogcmVtYXRjaFxuICAgICAgICAgICAgXCJAa2V5d29yZHNcIjogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgICBcIkBidWlsdGluc1wiOiBcInByZWRlZmluZWRcIixcbiAgICAgICAgICAgIFwiQGRlZmF1bHRcIjogXCJpZGVudGlmaWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHJvb3RcIiB9XG4gICAgXSxcbiAgICAvLyB1c2VkIHRvIHByZXZlbnQgcG90ZW50aWFsIG1vZGlmaWVycyAoJ2lmfHVudGlsfHdoaWxlfHVubGVzcycpIHRvIG1hdGNoXG4gICAgLy8gd2l0aCAnZW5kJyBrZXl3b3Jkcy5cbiAgICAvLyBtb2RpZmllci48ZGVjbD54IHdoZXJlIGRlY2wgaXMgdGhlIGRlY2xhcmF0aW9uIHN0YXJ0ZXIsIGxpa2UgJ2lmJ1xuICAgIG1vZGlmaWVyOiBbXG4gICAgICBbL14vLCBcIlwiLCBcIkBwb3BcIl0sXG4gICAgICAvLyBpdCB3YXMgYSBtb2RpZmllcjogZ2V0IG91dCBvZiBtb2RpZmllciBtb2RlIG9uIGEgbmV3IGxpbmVcbiAgICAgIFtcbiAgICAgICAgL1thLXpfXVxcdypbIT89XT8vLFxuICAgICAgICB7XG4gICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgIGVuZDogeyB0b2tlbjogXCJrZXl3b3JkLiRTMlwiLCBuZXh0OiBcIkBwb3BcIiB9LFxuICAgICAgICAgICAgLy8gZW5kIG9uIHNhbWUgbGluZVxuICAgICAgICAgICAgXCJ0aGVufGVsc2V8ZWxzaWZ8ZG9cIjoge1xuICAgICAgICAgICAgICB0b2tlbjogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgICAgIHN3aXRjaFRvOiBcIkByb290LiRTMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcmVhbCBkZWNsYXJhdGlvbiBhbmQgbm90IGEgbW9kaWZpZXJcbiAgICAgICAgICAgIFwiQGxpbmVkZWNsc1wiOiB7XG4gICAgICAgICAgICAgIHRva2VuOiBcIkByZW1hdGNoXCIsXG4gICAgICAgICAgICAgIHN3aXRjaFRvOiBcIkByb290LiRTMlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gb3RoZXIgZGVjbGFyYXRpb24gPT4gbm90IGEgbW9kaWZpZXJcbiAgICAgICAgICAgIFwiQGtleXdvcmRzXCI6IFwia2V5d29yZFwiLFxuICAgICAgICAgICAgXCJAYnVpbHRpbnNcIjogXCJwcmVkZWZpbmVkXCIsXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwiaWRlbnRpZmllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBpbmNsdWRlOiBcIkByb290XCIgfVxuICAgIF0sXG4gICAgLy8gc2luZ2xlIHF1b3RlIHN0cmluZ3MgKGFsc28gdXNlZCBmb3Igc3ltYm9scylcbiAgICAvLyBzc3RyaW5nLjxraW5kPiAgd2hlcmUga2luZCBpcyAnc3EnIChzaW5nbGUgcXVvdGUpIG9yICdzJyAoc3ltYm9sKVxuICAgIHNzdHJpbmc6IFtcbiAgICAgIFsvW15cXFxcJ10rLywgXCJzdHJpbmcuJFMyXCJdLFxuICAgICAgWy9cXFxcXFxcXHxcXFxcJ3xcXFxcJC8sIFwic3RyaW5nLiRTMi5lc2NhcGVcIl0sXG4gICAgICBbL1xcXFwuLywgXCJzdHJpbmcuJFMyLmludmFsaWRcIl0sXG4gICAgICBbLycvLCB7IHRva2VuOiBcInN0cmluZy4kUzIuZGVsaW1cIiwgbmV4dDogXCJAcG9wXCIgfV1cbiAgICBdLFxuICAgIC8vIGRvdWJsZSBxdW90ZWQgXCJzdHJpbmdcIi5cbiAgICAvLyBkc3RyaW5nLjxraW5kPi48ZGVsaW0+IHdoZXJlIGtpbmQgaXMgJ2QnIChkb3VibGUgcXVvdGVkKSwgJ3gnIChjb21tYW5kKSwgb3IgJ3MnIChzeW1ib2wpXG4gICAgLy8gYW5kIGRlbGltIGlzIHRoZSBlbmRpbmcgZGVsaW1pdGVyIChcIiBvciBgKVxuICAgIGRzdHJpbmc6IFtcbiAgICAgIFsvW15cXFxcYFwiI10rLywgXCJzdHJpbmcuJFMyXCJdLFxuICAgICAgWy8jLywgXCJzdHJpbmcuJFMyLmVzY2FwZVwiLCBcIkBpbnRlcnBvbGF0ZWRcIl0sXG4gICAgICBbL1xcXFwkLywgXCJzdHJpbmcuJFMyLmVzY2FwZVwiXSxcbiAgICAgIFsvQGVzY2FwZXMvLCBcInN0cmluZy4kUzIuZXNjYXBlXCJdLFxuICAgICAgWy9cXFxcLi8sIFwic3RyaW5nLiRTMi5lc2NhcGUuaW52YWxpZFwiXSxcbiAgICAgIFtcbiAgICAgICAgL1tgXCJdLyxcbiAgICAgICAge1xuICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICBcIiQjPT0kUzNcIjogeyB0b2tlbjogXCJzdHJpbmcuJFMyLmRlbGltXCIsIG5leHQ6IFwiQHBvcFwiIH0sXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwic3RyaW5nLiRTMlwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgXSxcbiAgICAvLyBsaXRlcmFsIGRvY3VtZW50c1xuICAgIC8vIGhlcmVkb2MuPGNsb3NlPiB3aGVyZSBjbG9zZSBpcyB0aGUgY2xvc2luZyBkZWxpbWl0ZXJcbiAgICBoZXJlZG9jOiBbXG4gICAgICBbXG4gICAgICAgIC9eKFxccyopKEBoZXJlZGVsaW0pJC8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgXCIkMj09JFMyXCI6IFtcInN0cmluZy5oZXJlZG9jXCIsIHsgdG9rZW46IFwic3RyaW5nLmhlcmVkb2MuZGVsaW1pdGVyXCIsIG5leHQ6IFwiQHBvcFwiIH1dLFxuICAgICAgICAgICAgXCJAZGVmYXVsdFwiOiBbXCJzdHJpbmcuaGVyZWRvY1wiLCBcInN0cmluZy5oZXJlZG9jXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgWy8uKi8sIFwic3RyaW5nLmhlcmVkb2NcIl1cbiAgICBdLFxuICAgIC8vIGludGVycG9sYXRlZCBzZXF1ZW5jZVxuICAgIGludGVycG9sYXRlZDogW1xuICAgICAgWy9cXCRcXHcqLywgXCJnbG9iYWwuY29uc3RhbnRcIiwgXCJAcG9wXCJdLFxuICAgICAgWy9AXFx3Ki8sIFwibmFtZXNwYWNlLmNsYXNzLmlkZW50aWZpZXJcIiwgXCJAcG9wXCJdLFxuICAgICAgWy9AQEBcXHcqLywgXCJuYW1lc3BhY2UuaW5zdGFuY2UuaWRlbnRpZmllclwiLCBcIkBwb3BcIl0sXG4gICAgICBbXG4gICAgICAgIC9be10vLFxuICAgICAgICB7XG4gICAgICAgICAgdG9rZW46IFwic3RyaW5nLmVzY2FwZS5jdXJseVwiLFxuICAgICAgICAgIHN3aXRjaFRvOiBcIkBpbnRlcnBvbGF0ZWRfY29tcG91bmRcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgW1wiXCIsIFwiXCIsIFwiQHBvcFwiXVxuICAgICAgLy8ganVzdCBhICMgaXMgaW50ZXJwcmV0ZWQgYXMgYSAjXG4gICAgXSxcbiAgICAvLyBhbnkgY29kZVxuICAgIGludGVycG9sYXRlZF9jb21wb3VuZDogW1xuICAgICAgWy9bfV0vLCB7IHRva2VuOiBcInN0cmluZy5lc2NhcGUuY3VybHlcIiwgbmV4dDogXCJAcG9wXCIgfV0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHJvb3RcIiB9XG4gICAgXSxcbiAgICAvLyAlciBxdW90ZWQgcmVnZXhwXG4gICAgLy8gcHJlZ2V4cC48b3Blbj4uPGNsb3NlPiB3aGVyZSBvcGVuL2Nsb3NlIGFyZSB0aGUgb3Blbi9jbG9zZSBkZWxpbWl0ZXJcbiAgICBwcmVnZXhwOiBbXG4gICAgICB7IGluY2x1ZGU6IFwiQHdoaXRlc3BhY2VcIiB9LFxuICAgICAgLy8gdHVybnMgb3V0IHRoYXQgeW91IGNhbiBxdW90ZSB1c2luZyByZWdleCBjb250cm9sIGNoYXJhY3RlcnMsIGFhcmdoIVxuICAgICAgLy8gZm9yIGV4YW1wbGU7ICVyfGtnamdhanwgaXMgb2sgKGV2ZW4gdGhvdWdoIHwgaXMgdXNlZCBmb3IgYWx0ZXJuYXRpb24pXG4gICAgICAvLyBzbywgd2UgbmVlZCB0byBtYXRjaCB0aG9zZSBmaXJzdFxuICAgICAgW1xuICAgICAgICAvW15cXChcXHtcXFtcXFxcXS8sXG4gICAgICAgIHtcbiAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgXCIkIz09JFMzXCI6IHsgdG9rZW46IFwicmVnZXhwLmRlbGltXCIsIG5leHQ6IFwiQHBvcFwiIH0sXG4gICAgICAgICAgICBcIiQjPT0kUzJcIjogeyB0b2tlbjogXCJyZWdleHAuZGVsaW1cIiwgbmV4dDogXCJAcHVzaFwiIH0sXG4gICAgICAgICAgICAvLyBuZXN0ZWQgZGVsaW1pdGVycyBhcmUgYWxsb3dlZC4uXG4gICAgICAgICAgICBcIn5bKX1cXFxcXV1cIjogXCJAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sXCIsXG4gICAgICAgICAgICBcIn5AcmVnZXhwY3RsXCI6IFwicmVnZXhwLmVzY2FwZS5jb250cm9sXCIsXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwicmVnZXhwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGluY2x1ZGU6IFwiQHJlZ2V4Y29udHJvbFwiIH1cbiAgICBdLFxuICAgIC8vIFdlIG1hdGNoIHJlZ3VsYXIgZXhwcmVzc2lvbiBxdWl0ZSBwcmVjaXNlbHlcbiAgICByZWdleHA6IFtcbiAgICAgIHsgaW5jbHVkZTogXCJAcmVnZXhjb250cm9sXCIgfSxcbiAgICAgIFsvW15cXFxcXFwvXS8sIFwicmVnZXhwXCJdLFxuICAgICAgW1wiL1tpeG1wXSpcIiwgeyB0b2tlbjogXCJyZWdleHAuZGVsaW1cIiB9LCBcIkBwb3BcIl1cbiAgICBdLFxuICAgIHJlZ2V4Y29udHJvbDogW1xuICAgICAgW1xuICAgICAgICAvKFxceykoXFxkKyg/OixcXGQqKT8pKFxcfSkvLFxuICAgICAgICBbXG4gICAgICAgICAgXCJAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sXCIsXG4gICAgICAgICAgXCJyZWdleHAuZXNjYXBlLmNvbnRyb2xcIixcbiAgICAgICAgICBcIkBicmFja2V0cy5yZWdleHAuZXNjYXBlLmNvbnRyb2xcIlxuICAgICAgICBdXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAvKFxcWykoXFxePykvLFxuICAgICAgICBbXCJAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sXCIsIHsgdG9rZW46IFwicmVnZXhwLmVzY2FwZS5jb250cm9sXCIsIG5leHQ6IFwiQHJlZ2V4cmFuZ2VcIiB9XVxuICAgICAgXSxcbiAgICAgIFsvKFxcKCkoXFw/Wzo9IV0pLywgW1wiQGJyYWNrZXRzLnJlZ2V4cC5lc2NhcGUuY29udHJvbFwiLCBcInJlZ2V4cC5lc2NhcGUuY29udHJvbFwiXV0sXG4gICAgICBbL1xcKFxcPyMvLCB7IHRva2VuOiBcInJlZ2V4cC5lc2NhcGUuY29udHJvbFwiLCBuZXh0OiBcIkByZWdleHBjb21tZW50XCIgfV0sXG4gICAgICBbL1soKV0vLCBcIkBicmFja2V0cy5yZWdleHAuZXNjYXBlLmNvbnRyb2xcIl0sXG4gICAgICBbL0ByZWdleHBjdGwvLCBcInJlZ2V4cC5lc2NhcGUuY29udHJvbFwiXSxcbiAgICAgIFsvXFxcXCQvLCBcInJlZ2V4cC5lc2NhcGVcIl0sXG4gICAgICBbL0ByZWdleHBlc2MvLCBcInJlZ2V4cC5lc2NhcGVcIl0sXG4gICAgICBbL1xcXFxcXC4vLCBcInJlZ2V4cC5pbnZhbGlkXCJdLFxuICAgICAgWy8jLywgXCJyZWdleHAuZXNjYXBlXCIsIFwiQGludGVycG9sYXRlZFwiXVxuICAgIF0sXG4gICAgcmVnZXhyYW5nZTogW1xuICAgICAgWy8tLywgXCJyZWdleHAuZXNjYXBlLmNvbnRyb2xcIl0sXG4gICAgICBbL1xcXi8sIFwicmVnZXhwLmludmFsaWRcIl0sXG4gICAgICBbL1xcXFwkLywgXCJyZWdleHAuZXNjYXBlXCJdLFxuICAgICAgWy9AcmVnZXhwZXNjLywgXCJyZWdleHAuZXNjYXBlXCJdLFxuICAgICAgWy9bXlxcXV0vLCBcInJlZ2V4cFwiXSxcbiAgICAgIFsvXFxdLywgXCJAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sXCIsIFwiQHBvcFwiXVxuICAgIF0sXG4gICAgcmVnZXhwY29tbWVudDogW1xuICAgICAgWy9bXildKy8sIFwiY29tbWVudFwiXSxcbiAgICAgIFsvXFwpLywgeyB0b2tlbjogXCJyZWdleHAuZXNjYXBlLmNvbnRyb2xcIiwgbmV4dDogXCJAcG9wXCIgfV1cbiAgICBdLFxuICAgIC8vICUgcXVvdGVkIHN0cmluZ3NcbiAgICAvLyBBIGJpdCByZXBldGl0aXZlIHNpbmNlIHdlIG5lZWQgdG8gb2Z0ZW4gc3BlY2lhbCBjYXNlIHRoZSBraW5kIG9mIGVuZGluZyBkZWxpbWl0ZXJcbiAgICBwc3RyaW5nOiBbXG4gICAgICBbLyUoW3F3c10pXFwoLywgeyB0b2tlbjogXCJzdHJpbmcuJDEuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHFzdHJpbmcuJDEuKC4pXCIgfV0sXG4gICAgICBbLyUoW3F3c10pXFxbLywgeyB0b2tlbjogXCJzdHJpbmcuJDEuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHFzdHJpbmcuJDEuWy5dXCIgfV0sXG4gICAgICBbLyUoW3F3c10pXFx7LywgeyB0b2tlbjogXCJzdHJpbmcuJDEuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHFzdHJpbmcuJDEuey59XCIgfV0sXG4gICAgICBbLyUoW3F3c10pPC8sIHsgdG9rZW46IFwic3RyaW5nLiQxLmRlbGltXCIsIHN3aXRjaFRvOiBcIkBxc3RyaW5nLiQxLjwuPlwiIH1dLFxuICAgICAgWy8lKFtxd3NdKShAZGVsaW0pLywgeyB0b2tlbjogXCJzdHJpbmcuJDEuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHFzdHJpbmcuJDEuJDIuJDJcIiB9XSxcbiAgICAgIFsvJXJcXCgvLCB7IHRva2VuOiBcInJlZ2V4cC5kZWxpbVwiLCBzd2l0Y2hUbzogXCJAcHJlZ2V4cC4oLilcIiB9XSxcbiAgICAgIFsvJXJcXFsvLCB7IHRva2VuOiBcInJlZ2V4cC5kZWxpbVwiLCBzd2l0Y2hUbzogXCJAcHJlZ2V4cC5bLl1cIiB9XSxcbiAgICAgIFsvJXJcXHsvLCB7IHRva2VuOiBcInJlZ2V4cC5kZWxpbVwiLCBzd2l0Y2hUbzogXCJAcHJlZ2V4cC57Ln1cIiB9XSxcbiAgICAgIFsvJXI8LywgeyB0b2tlbjogXCJyZWdleHAuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHByZWdleHAuPC4+XCIgfV0sXG4gICAgICBbLyVyKEBkZWxpbSkvLCB7IHRva2VuOiBcInJlZ2V4cC5kZWxpbVwiLCBzd2l0Y2hUbzogXCJAcHJlZ2V4cC4kMS4kMVwiIH1dLFxuICAgICAgWy8lKHh8V3xRPylcXCgvLCB7IHRva2VuOiBcInN0cmluZy4kMS5kZWxpbVwiLCBzd2l0Y2hUbzogXCJAcXFzdHJpbmcuJDEuKC4pXCIgfV0sXG4gICAgICBbLyUoeHxXfFE/KVxcWy8sIHsgdG9rZW46IFwic3RyaW5nLiQxLmRlbGltXCIsIHN3aXRjaFRvOiBcIkBxcXN0cmluZy4kMS5bLl1cIiB9XSxcbiAgICAgIFsvJSh4fFd8UT8pXFx7LywgeyB0b2tlbjogXCJzdHJpbmcuJDEuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHFxc3RyaW5nLiQxLnsufVwiIH1dLFxuICAgICAgWy8lKHh8V3xRPyk8LywgeyB0b2tlbjogXCJzdHJpbmcuJDEuZGVsaW1cIiwgc3dpdGNoVG86IFwiQHFxc3RyaW5nLiQxLjwuPlwiIH1dLFxuICAgICAgWy8lKHh8V3xRPykoQGRlbGltKS8sIHsgdG9rZW46IFwic3RyaW5nLiQxLmRlbGltXCIsIHN3aXRjaFRvOiBcIkBxcXN0cmluZy4kMS4kMi4kMlwiIH1dLFxuICAgICAgWy8lKFtycXdzeFddfFE/KS4vLCB7IHRva2VuOiBcImludmFsaWRcIiwgbmV4dDogXCJAcG9wXCIgfV0sXG4gICAgICAvLyByZWNvdmVyXG4gICAgICBbLy4vLCB7IHRva2VuOiBcImludmFsaWRcIiwgbmV4dDogXCJAcG9wXCIgfV1cbiAgICAgIC8vIHJlY292ZXJcbiAgICBdLFxuICAgIC8vIG5vbi1leHBhbmRlZCBxdW90ZWQgc3RyaW5nLlxuICAgIC8vIHFzdHJpbmcuPGtpbmQ+LjxvcGVuPi48Y2xvc2U+XG4gICAgLy8gIGtpbmQgPSBxfHd8cyAgKHNpbmdsZSBxdW90ZSwgYXJyYXksIHN5bWJvbClcbiAgICAvLyAgb3BlbiA9IG9wZW4gZGVsaW1pdGVyXG4gICAgLy8gIGNsb3NlID0gY2xvc2UgZGVsaW1pdGVyXG4gICAgcXN0cmluZzogW1xuICAgICAgWy9cXFxcJC8sIFwic3RyaW5nLiRTMi5lc2NhcGVcIl0sXG4gICAgICBbL1xcXFwuLywgXCJzdHJpbmcuJFMyLmVzY2FwZVwiXSxcbiAgICAgIFtcbiAgICAgICAgLy4vLFxuICAgICAgICB7XG4gICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgIFwiJCM9PSRTNFwiOiB7IHRva2VuOiBcInN0cmluZy4kUzIuZGVsaW1cIiwgbmV4dDogXCJAcG9wXCIgfSxcbiAgICAgICAgICAgIFwiJCM9PSRTM1wiOiB7IHRva2VuOiBcInN0cmluZy4kUzIuZGVsaW1cIiwgbmV4dDogXCJAcHVzaFwiIH0sXG4gICAgICAgICAgICAvLyBuZXN0ZWQgZGVsaW1pdGVycyBhcmUgYWxsb3dlZC4uXG4gICAgICAgICAgICBcIkBkZWZhdWx0XCI6IFwic3RyaW5nLiRTMlwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgXSxcbiAgICAvLyBleHBhbmRlZCBxdW90ZWQgc3RyaW5nLlxuICAgIC8vIHFxc3RyaW5nLjxraW5kPi48b3Blbj4uPGNsb3NlPlxuICAgIC8vICBraW5kID0gUXxXfHggIChkb3VibGUgcXVvdGUsIGFycmF5LCBjb21tYW5kKVxuICAgIC8vICBvcGVuID0gb3BlbiBkZWxpbWl0ZXJcbiAgICAvLyAgY2xvc2UgPSBjbG9zZSBkZWxpbWl0ZXJcbiAgICBxcXN0cmluZzogW1svIy8sIFwic3RyaW5nLiRTMi5lc2NhcGVcIiwgXCJAaW50ZXJwb2xhdGVkXCJdLCB7IGluY2x1ZGU6IFwiQHFzdHJpbmdcIiB9XSxcbiAgICAvLyB3aGl0ZXNwYWNlICYgY29tbWVudHNcbiAgICB3aGl0ZXNwYWNlOiBbXG4gICAgICBbL1sgXFx0XFxyXFxuXSsvLCBcIlwiXSxcbiAgICAgIFsvXlxccyo9YmVnaW5cXGIvLCBcImNvbW1lbnRcIiwgXCJAY29tbWVudFwiXSxcbiAgICAgIFsvIy4qJC8sIFwiY29tbWVudFwiXVxuICAgIF0sXG4gICAgY29tbWVudDogW1xuICAgICAgWy9bXj1dKy8sIFwiY29tbWVudFwiXSxcbiAgICAgIFsvXlxccyo9YmVnaW5cXGIvLCBcImNvbW1lbnQuaW52YWxpZFwiXSxcbiAgICAgIC8vIG5lc3RlZCBjb21tZW50XG4gICAgICBbL15cXHMqPWVuZFxcYi4qLywgXCJjb21tZW50XCIsIFwiQHBvcFwiXSxcbiAgICAgIFsvWz1dLywgXCJjb21tZW50XCJdXG4gICAgXVxuICB9XG59O1xuZXhwb3J0IHtcbiAgY29uZixcbiAgbGFuZ3VhZ2Vcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=